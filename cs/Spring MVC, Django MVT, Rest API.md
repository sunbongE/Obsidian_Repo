
# MVC 패턴
model view controller의 약자로 model은 데이터를 조작하는 역할, view는 화면단에 표출되는 페이지, 컨트롤러는 비지니스 로직을 담당한다.


# MVT 패턴
MVC패턴 기반이며 model, view, template의 약자이다.
Django에서 view는 비지니스 로직을 담당하며, template은 장고 템플릿(화면단)을 의미한다.
model은 동일한 역할을 한다.

# Rest API
Json 형식으로 데이터를 주고 받는 방식으로 백엔드와 프론트엔드를 분리하여 개발하는 것이 가능하다.
특징으로 무상태(stateless), 캐시 가능(cacheable), 일관된 인터페이스, 자체 서술적 메시지를 가질 수 있고, Client - Server 구조를 가진다.

# MVC 패턴 요청 과정
**구성 요소**
- DispatcherServlet
	- 가장 먼저 요청을 받기 때문에 프론트 컨트롤러라고도 한다.
- HandlerMapping
	- 어떤 컨트롤러로 요청을 전달할지 결정해주는 역할
- Controller
	- 비지니스 로직을 수행
- ViewResolver
	- 어떤 뷰(화면)을 선택할지 결정하는 역할을 한다.
- View
	- 화면에 데이터를 표출하여 사용자에게 인터페이스를 제공
**과정**
1. 사용자 요청
2. 디스페처 서블릿이 요청을 받는다.
3. 받은 요청을 어떤 비지니스 로직으로 수행해야 할지 핸들러 매핑에게 물어본다.
4. 핸들러 매핑은 어떤 컨트롤러로 전달하라고 알려준다.
5. 디스페처 서블릿이 전달받은 컨트롤러로 요청을 전달한다.
6. 컨트롤러에서 비즈니스 로직을 수행 후, ModelAndView를 전달한다.
7. 디스페처 서블릿이 전달 받고, 뷰리솔버에게 어떤 뷰를 사용할지 view를 전달해서 물어본다.
8. 뷰리솔버가 어떤 뷰를 사용할지 알려준다.
9. 디스페처 서블릿이 특정 뷰에게 데이터를 전달한다.
10. 뷰에서 인터페이스를 만들어서 사용자에게 제공한다.
![[Spring-MVC-Framework-Control-flow-Diagram.png]]
#  MVT 패턴 요청 과정
**구성요소**
- URLconf(URL Configuration)
	- 사용자의 요청 URL이 어떤 VIEW 함수로 연결될지 라우팅하는 설정
- View
	- 비즈니스 로직 수행
- Model
	- 데이터베이스와 연결되어 데이터를 처리, 제공 역할
- Template
	- 사용자에게 제공되는 인터페이스
**과정**
1. 사용자 요청
2. URLconf 를 통해 어떤 view 함수나 클래스로 라우팅할지 결정
3. view에서 로직 수행 후 데이터를 Template에 전달한다.
4. Template은 데이터를 사용해 HTML 페이지를 생성한다.
5. 사용자에게 인터페이스 제공
![[mvtPattern.png]]
# Spring에서 Rest API 요청 과정

**구성 요소**
- DispatcherServlet
	- 가장 먼저 요청을 받기 때문에 프론트 컨트롤러라고도 한다.
- HandlerMapping
	- 어떤 컨트롤러로 요청을 전달할지 결정해주는 역할
- Controller(@RestController)
	- 비지니스 로직을 수행, JSON 데이터를 반환
- HttpMessageConverter
	- Controller가 반환한 자바 객체를 JSON 등으로 자동 변환

**과정**
1. 사용자 요청
2. 디스페처 서블릿이 요청을 받는다.
3. 받은 요청을 어떤 비지니스 로직으로 수행해야 할지 핸들러 매핑에게 물어본다.
4. 핸들러 매핑은 어떤 컨트롤러로 전달하라고 알려준다.
5. 디스페처 서블릿이 전달받은 컨트롤러로 요청을 전달한다.
6. 컨트롤러에서 비즈니스 로직을 수행 후, HttpMessageConverter를 통해 자바 객체를 JSON변환해 전달한다.
7. 디스페처 서블릿이 JSON을 HTTP 응답으로 만들어 사용자에게 반환한다.

---

무상태(stateless)란?
기존 MVC 패턴은 세션을 통해 사용자의 상태를 서버 메모리에 저장해 관리했다.
로그인한 회원인지, 어떤 데이터를 가졌는지 등을 직접 관리하기 때문에 사용자가 많아지면 서버에 부하가 걸린다.
rest api 방식을 사용하면 보통 jsonWebToken(JWT)을 사용하는데 이때는 세션기반이 아닌 토큰기반으로 회원을 구분하며, 서버에서 상태를 따로 관리하지 않고 클라이언트가 토큰을 통해 상태정보를 포함시켜 요청한다.
때문에 세션 방식 보다 토큰 방식이 서버 부하가 적다.
