
> 커서 : 단일 로우가 아닌 멀티로우를 처리하도록 한다.
> 컬렉션 : 배열 계열


# 커서

> **커서(Cursor)**는 Oracle이 쿼리 결과를 저장하고, 한 줄씩 접근할 수 있게 해주는 **메모리 구조**

## Implicit Cursor (묵시적 커서)

> 묵시적 커서는 PL/SQL에 의해 생성되고 관리되는 세션 커서이다.
> 
> PL/SQL은 SELECT, DML문을 실행할 때마다 묵시적 커서를 연다.
> 묵시적 커서를 제어할수 없지만 해당 속성에 정보를 얻을 수 있다.


| 명령               | 역할                                            |
| ---------------- | --------------------------------------------- |
| SQL%ISOPEN       | 현재 커서가 열려 있는지 여부를 나타냄 (TRUE/FALSE)            |
| **SQL%FOUND**    | 마지막 SQL 문이 결과를 반환했는지 여부를 나타냄 (TRUE/FALSE)     |
| SQL%NOTFOUND     | 마지막 SQL 문이 결과를 반환하지 않았는지 여부를 나타냄 (TRUE/FALSE) |
| **SQL%ROWCOUNT** | 마지막 SQL 문에 의해 영향을 받은 행의 수를 반환함                |
|                  |                                               |

사용 예시
``` SQL

DECLARE
    CNT NUMBER;
BEGIN

    UPDATE REAL_ORD
    SET REG_DAY = SYSDATE
    WHERE CST_ID = 'C00S3';
    
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('UPDATE DATA CNT : '||SQL%ROWCOUNT);
    ELSE
        DBMS_OUTPUT.PUT_LINE('UPDATE DATA CNT : 0');
    END IF;
END;
/
```



---
## Explicit Cursors (명시적 커서)

> **명시적 커서**란, 개발자가 `SELECT` 결과를 **직접 처리**하기 위해 **명시적으로 선언하고 사용하는 커서**를 말한다.

### 구조 정리 (4단계)
``` SQL
-- 1. 커서 선언 
CURSOR cursor_name IS     SELECT ...;  

-- 2. 커서 열기
OPEN cursor_name;  

-- 3. 데이터 가져오기
FETCH cursor_name INTO 변수;  

-- 4. 커서 닫기 
CLOSE cursor_name;
```

### 선언 위치

`DECLARE` 블록 내부

사용 예시
``` sql
DECLARE
    p_cst_id varchar2(20);
BEGIN
    p_cst_id := null;
    
    for fc in ( select cst_id, name from cst_info where cst_id = nvl(p_cst_id,cst_id))
    loop
        dbms_output.put_line(fc.cst_id || '-' || fc.name);
    end loop;
    
END;
```

for loop와 함께 사용하면 코드 수가 줄어든다.
실무에서 많이 사용하는 방법이라고 함.
`fc` 에는 괄호 안에 쿼리문 결과가 받아진다.


## strong 타입의 선언 변수

장점
- 타입 안정성(Type Safety)
- **스키마 변경에 강함**
	- `cst_info` 테이블에 컬럼이 추가/변경되면, `%ROWTYPE`이 자동 반영돼서 변경 관리가 쉬움. `Record` 타입 사용도 마찬가지.
- 가독성/유지보수성 향상
- 레코드 단위 처리에 유리 

프로시저에서 특정 테이블의 전체 정보를 레코드 단위로 다룰 때 사용하는 것이 좋다고 함.
쿼리 유연성이 필요하다면 **weak 타입 REF CURSOR**를 쓰는 게 나음

``` sql
DECLARE
    p_cst_id varchar2(20);
    -- 1. 커서 선언?
    type cstcurtyp is ref cursor return cst_info%rowtype;
    cur_cst_info cstcurtyp;
    
    v_cst_id cst_info.cst_id%type;
    v_name cst_info.name%type;  
    r_cst_info cst_info%rowtype;
    
BEGIN
    p_cst_id := null;
    -- 2. 커서 열기
    open cur_cst_info
        for select * from cst_info where cst_id = nvl(p_cst_id, cst_id);
            Loop
                -- 3. 데이터 가져오기.
                fetch cur_cst_info into r_cst_info;
                exit when cur_cst_info%notfound;
                dbms_output.put_line(r_cst_info.cst_id || '-' || r_cst_info.name);
            end loop;
    -- 4. 커서 닫기.
    close cur_cst_info;

END;
```








---

# 비교: 암묵적 커서 vs 명시적 커서

| 구분  | 암묵적 커서      | 명시적 커서      |
| --- | ----------- | ----------- |
| 선언  | ❌ 없음        | ✅ 직접 선언     |
| 제어  | Oracle이 자동  | 사용자가 직접 제어  |
| 대상  | 단일 행 처리     | 다중 행 처리     |
| 속성  | SQL%FOUND 등 | 커서명%FOUND 등 |
